# Copyright (c) 2013-2015 Centre for Advanced Internet Architectures,
# Swinburne University of Technology. All rights reserved.
#
# Author: Sebastian Zander (szander@swin.edu.au)
#         Grenville Armitage (garmitage@swin.edu.au)
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# Calculate the time offsets between different pcap files
# generated by specific TEACUP experiments
#
# Basic logic involves extracting ICMP frames that are transmitted
# roughly every 2 seconds by a local switch, and (we assume) received
# by all attached devices at the 'same time'. Hence the differences
# in the timestamps at which each ICMP frame is received gives the
# difference between the clocks of each host. At least, that's
# the idea assuming the ICMP frames are delivered at close to
# identical times on each TEACUP switch port.
#
# $Id: clockoffset.py 1008 2015-02-18 03:19:20Z szander $

import os
import socket
import csv
import tempfile
from subprocess import *
from fabric.api import task, warn, put, puts, get, local, run, execute, \
    settings, abort, hosts, env, runs_once, parallel
import config


# Create a safe place to dump output from stderr of the various shell processes
stderrhack = os.tmpfile()


# Build a list of strings from a number of string lines
# Parameters:
#       lines: string lines
# Return:
#       List with one entry per line
def _list(lines):
    ret = []
    for line in lines.split('\n'):
        if line != '':
            ret.append(line)

    return ret


# file extension for clock offset file
CLOCK_OFFSET_FILE_EXT = '_clock_offsets.txt'

# extension for modified data file
DATA_CORRECTED_FILE_EXT = '.tscorr'


# Specify tcpdump filter rule to identify frames whose timestamps
# we will compare (assumed to be frames seen identically at each
# host and router interface)

bc_ping_enable = '0'
try:
    bc_ping_enable = config.TPCONF_bc_ping_enable
except AttributeError:
    pass

bc_addr = ''
try:
    bc_addr = config.TPCONF_bc_ping_address
except AttributeError:
    pass

if bc_ping_enable and bc_addr == '':
    rout_ctl_ip = socket.gethostbyname(config.TPCONF_router[0].split(':')[0])
    addr_arr = rout_ctl_ip.split('.')
    addr_arr[3] = '255'
    bc_addr = '.'.join(addr_arr)


PKT_FILTER = "icmp and dst host " + bc_addr


# Get file with time offsets for each experiment host
# Parameters:
#       exp_list: file that lists experiments to process
#       test_id: specific experiment
#	pkt_filter: tcpdump filter string to filter braoadcast ping packets
# 	baseline_host: host we compute offset against
#                      (by default the router)
#       out_dir: output directory for results
@task
def get_clock_offsets(exp_list='experiments_completed.txt',
                      test_id='', pkt_filter=PKT_FILTER,
                      baseline_host=config.TPCONF_router[0],
                      out_dir=''):
    "Get clock offsets for all hosts"

    if len(out_dir) > 0 and out_dir[-1] != '/':
        out_dir += '/'

    if test_id == '':
        try:
            with open(exp_list) as f:
                test_id_arr = f.readlines()
        except IOError:
            abort('Cannot open file %s' % exp_list)
    else:
        test_id_arr = test_id.split(';')

    if len(test_id_arr) == 0 or test_id_arr[0] == '':
        abort('Must specify test_id parameter')

    # specify complete tcpdump parameter list
    tcpdump_filter = '-tt -r - -n ' + pkt_filter

    for test_id in test_id_arr:
        test_id = test_id.rstrip()

        # first find tcpdump files
        tcpdump_files = _list(
            local(
                'find -L . -name "%s*_ctl.dmp.gz" -print | '
                'sed -e "s/\.\///"' %
                test_id,
                capture=True))

        if len(tcpdump_files) == 0:
            continue

        # read timestamps from each host's tcpdump

        # map of host names (or IPs) and sequence numbers to timestamps
        host_times = {}
        for tcpdump_file in tcpdump_files:
            host = local(
                'echo %s | sed "s/.*_\([a-z0-9\.]*\)_ctl.dmp.gz/\\1/"' %
                tcpdump_file,
                capture=True)
            host_times[host] = {}
            # print(host_times)

            # We pipe gzcat through to tcpdump. Note, since tcpdump exits early
            # (due to "-c num_samples") gzcat's pipe will collapse and gzcat
            # will complain bitterly. So we dump its stderr to stderrhack.
            init_zcat = Popen(['zcat ' + tcpdump_file], stdin=None,
                              stdout=PIPE, stderr=stderrhack, shell=True)
            init_tcpdump = Popen(['tcpdump ' + tcpdump_filter],
                                 stdin=init_zcat.stdout,
                                 stdout=PIPE,
                                 stderr=stderrhack,
                                 shell=True)

            for line in init_tcpdump.stdout.read().splitlines():
                _time = line.split(" ")[0]
                _seq = int(line.split(" ")[11].replace(',', ''))
                host_times[host][_seq] = _time

        # print(host_times)

        # get time differences and get host list
        diffs = {}
        ref_times = {}
        host_str = ''
        host_list = sorted(host_times.keys())
        # getting hosts from the config is problematic if different 
        # experiments with different configs in same directory 
        #host_list = sorted(config.TPCONF_router + config.TPCONF_hosts)

        for host in host_list:
            host_str += ' ' + host
            if host not in host_times:
                continue
            for seq in sorted(host_times[host].keys()):
                if seq not in diffs:
                    diffs[seq] = {}
                if baseline_host in host_times and seq in host_times[
                        baseline_host]:
                    diffs[seq][host] = float(host_times[host][seq]) - \
                        float(host_times[baseline_host][seq])
                    ref_times[seq] = host_times[baseline_host][seq]
                else:
                    # this case should not never happen
                    diffs[seq][host] = None
                    ref_times[seq] = None

        # print(diffs)

        # write table of offsets (rows = time, cols = hosts)
        dir_name = os.path.dirname(tcpdump_files[0])
        local('mkdir -p %s' % dir_name + '/' + out_dir)
        out_name = dir_name + '/' + out_dir + test_id + CLOCK_OFFSET_FILE_EXT
        f = open(out_name, 'w')
        f.write('# ref_time' + host_str + '\n')
        for seq in sorted(diffs.keys()):
            if ref_times[seq] is not None:
                f.write(ref_times[seq])
            else:
                # this case should not never happen
                continue

            f.write(' ')

            for host in host_list:
                if host in diffs[seq] and diffs[seq][host] is not None:
                    f.write('{0:.6f}'.format(diffs[seq][host]))
                else:
                    f.write('NA')
                if host != host_list[-1]:
                    f.write(' ')
            f.write('\n')

        f.close()


# Adjust timestamps in result file
# Parameters:
#       test_id: specific experiment
#       file_name: data file
#       host_name: host the timestamps are from in the data file
#	sep: separator used in data file
@task
def adjust_timestamps(test_id='', file_name='', host_name='', sep=' '):
    "Adjust timestamps in data file based on observed clock offsets"

    # make sure file name has directory striped off
    file_name = os.path.basename(file_name)

    # locate data file
    file_name = _list(
        local(
            'find -L . -name "%s" -print | '
            'sed -e "s/\.\///"' %
            file_name,
            capture=True))[0]
    # get sub directory
    dir_name = local('dirname %s' % file_name, capture=True).split('/')[0]
    dir_name = os.path.dirname(file_name).split('/')[0]
    # clock offset file name
    offs_fname = dir_name + '/' + test_id + CLOCK_OFFSET_FILE_EXT
    # new file name
    new_fname = file_name + DATA_CORRECTED_FILE_EXT

    # print(offs_fname)

    if not os.path.isfile(offs_fname):
        execute(get_clock_offsets, test_id=test_id)

    host_times = []
    last_offs = 0.0
    try:
        with open(offs_fname) as f:
            offs_lines = f.readlines()

            # find column (note # is first column in first row
            host_col = -1
            for col in offs_lines[0].rstrip().split(' '):
                if col == host_name:
                    break

                host_col += 1
            # print(host_col)

            for line in offs_lines[1:]:
                line = line.rstrip()
                ref_time = line.split(' ')[0]
                offs = line.split(' ')[host_col]
                # if we have no data our offset for correction will be the
                # last offset != zero otherwise it will be the offset measured
                if offs == 'NA':
                    offs = last_offs
                else:
                    offs = float(offs)
                    last_offs = offs

                # XXX instead of using the instantenous offset values we may
                # want to do something better in the future, such as using
                # a weighted moving average etc.
                host_times.append((ref_time, offs))

    except IOError:
        abort('Cannot open file %s' % offs_fname)

    reader = csv.reader(open(file_name, 'r'), delimiter=sep)
    fout = open(new_fname, 'w')

    # index to curr_ref_time
    curr = 0
    for line in reader:
        time = line[0]

        # find the right time, we assume here that each offset is
        # valid from the time it was observed until the time the next
        # offset is observed
        while host_times[curr][0] < time or host_times[curr][0] == 'NA':
            curr += 1
        if curr > 0 and host_times[curr - 1][0] != 'NA':
            curr -= 1

        new_time = float(time) - host_times[curr][1]

        fout.write('{0:.6f}'.format(new_time) + sep)
        fout.write(sep.join(line[1:]))
        fout.write('\n')

    fout.close()

    return new_fname
